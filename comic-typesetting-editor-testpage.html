<!DOCTYPE HTML>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width user-scalable=0 initial-scale=1.0 mximum-scale=1.0 minimum-scale=1.0">
  <link rel="stylesheet" type="text/css" href="./comic-typesetting.css">
<style>
body {
  margin: 0 8px;
}
#top-menu {
  position: sticky;
  top: 0;
  z-index: 2147483647;
  width: 100%;
  padding: 8px 0;
  background: white;
}

.translate-items-wrapper {
  z-index: 0;
}
.edit-bubble-wrapper {
  position: absolute;
  display: flex;
  align-items: center;
  box-sizing: border-box;
  padding: 1%;
  border: 1px solid;
  font-size: 0.04em; /* img width / 25 */
  /* font-weight: bold; */
  word-break: keep-all;
  /* text-orientation: upright; */
  user-select: none;
}
.translate-item > .editor,
.edit-bubble-wrapper > .editor {
  position: absolute;
  bottom: calc(100% + 1px);
  left: 0;
}
.translate-item > .editor input[name="speaker"],
.edit-bubble-wrapper > .editor input[name="speaker"] {
  min-width: 100px;
}
.translate-item > input,
.translate-item > textarea,
.edit-bubble-wrapper > textarea,
.edit-bubble-wrapper > input {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  min-width: 100px;
  height: 100%;
  background: transparent;
  margin: 0;
  padding: 0;
  border: 0;
}

#guide-box {
  display: none;
  position: absolute;
  box-sizing: border-box;
  border: 2px dotted red;
}
.resizer { position: absolute; z-index: 1; }
.resizer.top { height: 2px; top: 0; left: 0; right: 0; cursor: ns-resize; }
.resizer.right { width: 2px; top: 0; bottom: 0; right: 0; cursor: ew-resize; }
.resizer.bottom { height: 2px; bottom: 0; left: 0; right: 0; cursor: ns-resize; }
.resizer.left { width: 2px; top: 0; bottom: 0; left: 0; cursor: ew-resize; }
.anchor {
  position: absolute;
  width: 15px;
  height: 15px;
  top: calc(100% - 10px);
  left: -10px;
  z-index: 2;
  cursor: move;
  background: #0F0;
}
.translate-item.edit {
  position: absolute;
  user-select: none;
}

#control-box {
  position: fixed;
  background: white;
  border: 1px solid black;
  right: 10px;
  bottom: 10px;
  padding: 10px;
  font-family: initial;
  font-size: initial;
}
</style>
  <style>
img {
  max-width: 100%;
}
  </style>
</head>
<body>

<div id="top-menu">
  <!-- control menu -->
  <div>
    <button id="save-button">저장</button>
    <button id="load-button">불러오기</button>
  </div>
  <div id="help-wrapper">
    <style>
      #help-wrapper {
        position: relative;
      }
      #help-box {
        display: none;
        position: absolute;
        top: calc(100% + 10px);
        width: 500px;
        max-width: 100%;
        box-sizing: border-box;
        padding: 8px;
        border: 1px solid black;
        background: white;
        z-index: 3;
      }
      input#show-help:checked + #help-box {
        display: block;
      }
    </style>
    <label>
      도움말 <input id="show-help" type="checkbox">
      <div id="help-box">
        드래그 드랍으로 말풍선 생성.<br>
        대사치는 인물의 이름, 저장, 삭제, 대사 입력 부분.<br>
        크기, 위치 조정 가능.<br>
        저장하면 저장됨.<br>
        다시 누르면 크기, 위치 조정 가능.<br>
        오른쪽 하단의 컨트롤박스와 연결됨.<br>
        정보 수정 후 저장.<br>
        다른 곳을 클릭하면 수정 취소.<br>
        상단의 저장을 누르면 localStorage 에 저장.<br>
        저장 한 번 되면 새로고침해도 영구 저장.<br>
      </div>
    </label>
  </div>
</div>

<div id="target"> </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/redom/3.27.1/redom.min.js" integrity="sha512-sNCK+U3nOuf3wX65xAdK2d1V49aok/CCWO0lKZGSA+yh4rShNTNPfraMskwlROq0kDGWLdRByHanLpLhgUIoeg==" crossorigin="anonymous"></script>
<script id="utils">
var html = redom.html;
var mount = redom.mount;
var unmount = redom.unmount;
// sugars
var fieldset = html.extend('fieldset');
var legend = html.extend('legend');
var label = html.extend('label');
var numberInput = html.extend('input', { type: 'number' });
var colorPicker = html.extend('input', { type: 'color' });
var rangeInput = html.extend('input', { type: 'range' });
var checkbox = html.extend('input', { type: 'checkbox' });

function rgbaToRgb(rgba) {
  if (rgba.match(/^(rgb|hsl)a/)) {
    return rgba.replace(/(rgb|hsl)a/, '$1').split(',').splice(0, 3).join(',') + ');';
  } else if (rgba.match(/#[0-9a-fA-F]{8}/)) {
    return rgba.slice(0, 7);
  } else if (rgba.match(/#[0-9a-fA-F]{4}/)) {
    return rgba.slice(0, 4);
  }
}
function getParentHasClass(dom, className, until) {
  if (!dom.classList.contains(until) && dom.parentElement) {
    if (dom.classList.contains(className)) return dom;
    return getParentHasClass(dom.parentElement, className, until);
  }
  return null;
}
// from https://www.kirupa.com/html5/getting_mouse_click_position.htm
// helper function to get an element's exact position
function getPosition (el) {
  var xPosition = 0;
  var yPosition = 0;

  while (el) {
    if (el.tagName == "BODY") {
      // deal with browser quirks with body/window/document and page scroll
      var xScrollPos = el.scrollLeft || document.documentElement.scrollLeft;
      var yScrollPos = el.scrollTop || document.documentElement.scrollTop;

      xPosition += (el.offsetLeft - xScrollPos + el.clientLeft);
      yPosition += (el.offsetTop - yScrollPos + el.clientTop);
    } else {
      xPosition += (el.offsetLeft - el.scrollLeft + el.clientLeft);
      yPosition += (el.offsetTop - el.scrollTop + el.clientTop);
    }

    el = el.offsetParent;
  }
  return {
    x: xPosition,
    y: yPosition
  };
}
</script>
<script id="comic-typesetting-core" src="./comic-typesetting.js"></script>
<script id="test-data">
var items = [
  /* 
  {"type":"serifu","speaker":["chihiro"],"style":{"top":"19.6%","left":"85.8%","height":"43.2%","width":"10.9%","z-index":"2147483647","background-color":"rgb(223, 251, 213)","border":"none","text-align":"center","padding":"0","border-radius":"1em 0 0 1em"},"text":"자 여러분 좋은 얼굴로~♪"},
  */
];
</script>
<script id="editor-view" src="./editor-view.js"></script>
<script id="view">
var view = {
  controlBox: new ControlBox(),
  guideBox: new GuideBox(),
  bubble: new Bubble()
};
</script>
<script id="app">
// get dom
var saveButton = document.querySelector('#save-button');
var loadButton = document.querySelector('#load-button');

// get params
var params = new URLSearchParams(location.search);
var imageUrl = params.get('imageUrl');

// make editor
var editor = new Editor('#target', imageUrl, view);

// bind
saveButton.addEventListener('click', save);
loadButton.addEventListener('click', load);

// app start
load();

function makeEditable(comicTypesetting, context, view) {

var ct = comicTypesetting;
var editor = context;

var translateItemsWrapper = ct._translateItemsWrapper;

mount(ct._wrapper, view.guideBox);
mount(ct._wrapper, view.controlBox);

var newImageWrapper = ct._imageWrapper.cloneNode();
newImageWrapper.id = 'original-image';
newImageWrapper.style.position = 'absolute';
newImageWrapper.style.left = '105%';
ct._wrapper.appendChild(newImageWrapper);
// 필요한 돔 넣기

var editorStatus = {
  isMousedown: false,
  createInput: false,
  prevX: 0,
  prevY: 0,
  isResizing: false,
  resizeTarget: null,
  isDragging: false,
  dragTarget: null,
  clickedBubble: null,
  clickedIndex: -1,
};

translateItemsWrapper.addEventListener('mousedown', function (e) {

  translateItemsWrapper.style.userSelect = 'none';

  function clear(bubble, reset) {
    if (reset !== undefined && !reset) {
      view.bubble.turnOffEditMode();
    } else {
      editor.reset();
    }
    editorStatus.clickedBubble = null;
    editorStatus.clickedIndex = -1;
  }
  function set(bubble) {
    view.bubble.bindDom(bubble);
    view.bubble.turnOnEditMode();
    view.bubble.saveButton.onclick = function () {
      var item = editor.getItems()[ct._bubbleItems.indexOf(bubble)];
      if (!item) return clear(bubble);
      if (view.bubble.bubble.querySelector('textarea')) {
        var text = bubble.querySelector('textarea').value.trim().replace(/\n/g, '<wbr>');
      } else if (view.bubble.textTag) {
        var text = view.bubble.textTag.innerHTML.trim().replace(/\n/g, '<wbr>');;
      }
      item.text = text;
      item.style = view.bubble.getStyle();
      clear(bubble);
    };
    view.bubble.cancelButton.onclick = function () { clear(bubble); };

    view.controlBox.bindCssControl(view.bubble.bubble);
  }

  editorStatus.isMousedown = true;
  var targetPos = getPosition(e.currentTarget);
  editorStatus.prevX = editorStatus.x = e.clientX - targetPos.x;
  editorStatus.prevY = editorStatus.y = e.clientY - targetPos.y + 1;
  if (e.target.tagName.toLowerCase() === 'ul') {
    editorStatus.createInput = true;
    if (editorStatus.clickedBubble) clear(editorStatus.clickedBubble);
  } else if (e.target.classList.contains('resizer')) {
    editorStatus.isResizing = true;
    editorStatus.resizeTarget = e.target;
  } else if (e.target.classList.contains('anchor')) {
    editorStatus.isDragging = true;
    var bubble = e.target.parentNode.parentNode;
    editorStatus.dragTarget = {
      bubble: bubble,
      top: bubble.style.top,
      left: bubble.style.left,
    };
  } else if (getParentHasClass(e.target, 'translate-item')) {
    var target = getParentHasClass(e.target, 'translate-item');
    if (target !== editorStatus.clickedBubble) {
      if (editorStatus.clickedBubble) clear(editorStatus.clickedBubble, false);
      editorStatus.clickedBubble = target;
      editorStatus.clickedIndex = ct._bubbleItems.indexOf(target);
      set(editorStatus.clickedBubble);
    }
  }

  editorStatus.moveX = editorStatus.prevX;
  editorStatus.moveY = editorStatus.prevY;
});
translateItemsWrapper.addEventListener('mousemove', function (e) {
  var targetPos = getPosition(e.currentTarget);
  editorStatus.x = e.clientX - targetPos.x;
  editorStatus.y = e.clientY - targetPos.y + 1;

  var deltaX = editorStatus.x - editorStatus.prevX;
  var deltaY = editorStatus.y - editorStatus.prevY;

  if (editorStatus.createInput && Math.abs(deltaX) > 10 && Math.abs(deltaY) > 10) {
    var width = translateItemsWrapper.offsetWidth;
    var height = translateItemsWrapper.offsetHeight;
    xs = [editorStatus.x / width, editorStatus.prevX / width].sort(function (a, b) { return a - b });
    ys = [editorStatus.y / height, editorStatus.prevY / height].sort(function (a, b) { return a - b });

    view.guideBox.setRect(xs, ys);
    view.guideBox.show();
  } else {
    view.guideBox.hide();
  }
  if (editorStatus.isResizing) {
    var width = translateItemsWrapper.offsetWidth;
    var height = translateItemsWrapper.offsetHeight;
    var resizer = editorStatus.resizeTarget;
    var boxView = resizer.parentElement.parentElement;
    var box = boxView.style;
    var currentX = (editorStatus.x / width * 100);
    var currentY = (editorStatus.y / height * 100);
    if (resizer.classList.contains('top')) {
      if (currentY < Number.parseFloat(box.top) + Number.parseFloat(box.height)) {
        var delta = currentY - Number.parseFloat(box.top);
        box.top = currentY + '%';
        box.height = Number.parseFloat(box.height) - delta + '%';
      }
    }
    if (resizer.classList.contains('right')) {
      if (currentX > Number.parseFloat(box.left)) {
        box.width = currentX - Number.parseFloat(box.left) + '%';
      }
    }
    if (resizer.classList.contains('bottom')) {
      if (currentY > Number.parseFloat(box.top)) {
        box.height = currentY - Number.parseFloat(box.top) + '%';
      }
    }
    if (resizer.classList.contains('left')) {
      if (currentX < Number.parseFloat(box.left) + Number.parseFloat(box.width)) {
        var delta = currentX - Number.parseFloat(box.left);
        box.left = currentX + '%';
        box.width = Number.parseFloat(box.width) - delta + '%';
      }
    }
  }
  if (editorStatus.isDragging) {
    var width = translateItemsWrapper.offsetWidth;
    var height = translateItemsWrapper.offsetHeight;
    var box = editorStatus.dragTarget.bubble.style;
    var previousTop = Number.parseFloat(editorStatus.dragTarget.top);
    var previousLeft = Number.parseFloat(editorStatus.dragTarget.left);
    var current = {
      x: (editorStatus.x / width * 100),
      y: (editorStatus.y / height * 100)
    };
    var prev = {
      x: (editorStatus.prevX / width * 100),
      y: (editorStatus.prevY / height * 100)
    };
    if (!e.shiftKey) {
      box.top = previousTop - prev.y + current.y + '%';
      box.left = previousLeft - prev.x + current.x + '%';
    } else {
      if (Math.abs(prev.y - current.y) > Math.abs(prev.x - current.x)) {
        box.top = previousTop - prev.y + current.y + '%';
        box.left = previousLeft + '%';
      } else {
        box.top = previousTop + '%';
        box.left = previousLeft - prev.x + current.x + '%';
      }
    }
  }
});
translateItemsWrapper.addEventListener('mouseup', function (e) {
  translateItemsWrapper.style.userSelect = '';

  editorStatus.isMousedown = false;
  var deltaX = editorStatus.x - editorStatus.prevX;
  var deltaY = editorStatus.y - editorStatus.prevY;
  if (editorStatus.createInput && Math.abs(deltaX) > 10 && Math.abs(deltaY) > 10) {
    var width = translateItemsWrapper.offsetWidth;
    var height = translateItemsWrapper.offsetHeight;
    xs = [editorStatus.x / width, editorStatus.prevX / width].sort();
    ys = [editorStatus.y / height, editorStatus.prevY / height].sort();

    // make new edit bubble
    var editBubbleWrapper = new EditBubbleWrapper(xs, ys);
    editBubbleWrapper.speakerInputTag.addEventListener('input', e => {
      editBubbleWrapper.changeClassWithSpeaker();
    });
    editBubbleWrapper.saveButtonTag.addEventListener('click', e => {
      editor.addItem(editBubbleWrapper.getBubbleInformation());
      unmount(translateItemsWrapper, editBubbleWrapper);
    });
    editBubbleWrapper.deleteButtonTag.addEventListener('click', e => {
      unmount(translateItemsWrapper, editBubbleWrapper);
    });
    mount(translateItemsWrapper, editBubbleWrapper);

    view.guideBox.hide();
  }
  editorStatus.createInput = false;
  editorStatus.isResizing = false;
  editorStatus.isDragging = false;
});
translateItemsWrapper.addEventListener('dblclick', function (e) {
  var targetPos = getPosition(e.currentTarget);

  var clickedX = e.clientX - targetPos.x;
  var clickedY = e.clientY - targetPos.y + 1;

  var RGBA = pixelPicker.get(clickedX, clickedY);
  var [R, G, B] = RGBA;
  var threshold = 12;

  var queue = [{ x: clickedX, y: clickedY }];
  var gather = [];
  var visited = {};
  var s = 2;
  while (queue.length) {
    var {x, y} = queue.pop();
    if (!visited[x + ',' + y]) {
      visited[x + ',' + y] = true;
      var rgba = pixelPicker.get(x, y);
      var [r, g, b, a] = rgba;
      if (a == 0) continue;
      if (r < 187 && g < 187 && b < 187) continue;
      if (!(
        (R - threshold < r && r < R + threshold) &&
        (G - threshold < g && g < G + threshold) &&
        (B - threshold < b && b < B + threshold)
      )) continue;
      gather.push({x, y});
      queue.push({ x: x + s, y : y });
      queue.push({ x: x - s, y : y });
      queue.push({ x: x, y : y + s });
      queue.push({ x: x, y : y - s });
    }
  }

  // console.log(gather);
  var xSet = new Set();
  var ySet = new Set();

  gather.forEach(({x, y}) => {
    /*
    var div = document.createElement('div');
    div.style.width = '1px';
    div.style.height = '1px';
    div.style.background = 'red';
    div.style.position = 'absolute';
    div.style.top = y + 'px';
    div.style.left = x + 'px';
    ct._wrapper.appendChild(div);
    */

    xSet.add(x);
    ySet.add(y);
  });

  var minX = Math.min(...xSet);
  var maxX = Math.max(...xSet);
  var minY = Math.min(...ySet);
  var maxY = Math.max(...ySet);

  var div = document.createElement('div');
  div.style.width = (maxX - minX) + 'px';
  div.style.height = (maxY - minY) + 'px';
  div.style.border = '1px dotted red';
  div.style.position = 'absolute';
  div.style.top = minY + 'px';
  div.style.left = minX + 'px';
  ct._wrapper.appendChild(div);
});

};

function Editor(targetSelector, imageUrl, view) {
  if (!targetSelector) {
    throw new Error('타겟 태그가 없습니다');
  }
  if (!imageUrl) {
    throw new Error('이미지가 없습니다');
  }

  this._target = new ComicTypesetting(targetSelector, imageUrl);
  this._info = translatedInfo = {
    author: '',
    items: [
    ],
  };

  makeEditable(this._target, this, view);

  this.addItem = function addItem(item) {
    this._info.items.push(item);
    this._target.setItems(this._info.items);
  };

  this.removeItem = function removeItem(index) {
    this._info.items.splice(0, index);
    this._target.setItems(this._info.items);
  };

  this.setItems = function setItems(items) {
    this._info.items = items;
    this._target.setItems(this._info.items);
  };

  this.setAuthor = (author) => {
    this._info.author = author;
  };

  this.reset = () => {
    this._target.setItems(this._info.items);
  };

  this.getItems = function getItems() {
    return this._info.items;
  };
}

function save(e) {
  var key = 'millishita-4coma-edit';
  key += '(' + imageUrl + ')';
  localStorage.setItem(key, JSON.stringify(editor.getItems()));
}

function load(e) {
  var key = 'millishita-4coma-edit';
  key += '(' + imageUrl + ')';
  var items = localStorage.getItem(key);
  if (!items) return;
  items = JSON.parse(items);
  editor.setItems(items);
}
</script>
<script>
var PixelPicker = function (selector) {
  var bind = (function bind() {
    this.canvas = document.createElement('canvas');
    this.canvas.width = img.width;
    this.canvas.height = img.height;
    this.canvas.getContext('2d').drawImage(img, 0, 0, img.width, img.height);
  }).bind(this);

  var img = document.querySelector(selector || 'img');
  if (img.complete) {
    bind();
  } else {
    img.addEventListener('load', () => {
      bind();
    });
  }
};
PixelPicker.prototype.get = function (x, y) {
  return this.canvas.getContext('2d').getImageData(x, y, 1, 1).data;
}

function getRect(dom, canvas) {
  const top = Math.floor(parseFloat(dom.style.top) * canvas.height / 100);
  const left = Math.floor(parseFloat(dom.style.left) * canvas.width / 100);
  const width = Math.floor(parseFloat(dom.style.width) * canvas.width / 100);
  const height = Math.floor(parseFloat(dom.style.height) * canvas.height / 100);
  return { top, left, width, height };
}

var pixelPicker = new PixelPicker();

function isSameColor(a, b) {
  const OFFSET = 15;
  if (!Array.isArray(a)) a = a.split(',').slice(0, 3);
  if (!Array.isArray(b)) b = b.split(',').slice(0, 3);
  a = a.map(n => +n);
  b = b.map(n => +n);
  var sum = 0;
  for (let i = 0; i < 3; i++) {
    sum += Math.pow((a[i] || 0) - (b[i] || 0), 2);
    }
  length = Math.sqrt(sum);
  return length < OFFSET;
}

function getSmartBackground(bubble, pixelPicker, x = 3) {
  const BLACK_THRESHOLD = 187;
  var r = getRect(bubble, pixelPicker.canvas);
  var o = {};
  for (let i = r.top; i < r.top + r.height; i += x) {
    for (let j = r.left; j < r.left + r.width; j += x) {
      const px = pixelPicker.get(j, i);
      const [red, green, blue] = px;
      if (red < BLACK_THRESHOLD && green < BLACK_THRESHOLD && blue < BLACK_THRESHOLD) {
        continue;
      }
      const ps = Array.from(px).map(i => i.toString().padStart(3, '0')).join(',');
      const en = o[ps] || { id: ps, count: 0 };
      en.count++;
      o[ps] = en;
    }
  }
  var candidates = Object.values(o).sort((a, b) => b.count - a.count).slice(0, 10);
  var primary = candidates[0];
  var secondaryColor = candidates.slice(1).find(c => !isSameColor(primary.id, c.id));

  var background = '';

  if (secondaryColor) {
    // gradient
    var degree = 0; // TODO
    background = `linear-gradient(${degree}deg,`
        + `rgb(${primary.id.split(',').map(a => +a).slice(0, 3).join(',')}), `
        + `rgb(${secondaryColor.id.split(',').map(a => +a).slice(0, 3).join(',')}))`;
  } else {
    background = `rgb(${primary.id.split(',').map(a => +a).slice(0, 3).join(',')})`;
  }

  return background;
}
</script>

</body>
